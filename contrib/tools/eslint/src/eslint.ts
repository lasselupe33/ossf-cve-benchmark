/**
 * This is the eslint driver for the CVE Benchmarker.
 * See ../README.md for how to use this driver.
 *
 * This driver is the reference driver for the CVE Benchmarker.
 */

import { execSync } from "child_process";
import * as fs from "fs-extra";
import * as path from "path";
import { performance } from "perf_hooks";
import {
  Analyze,
  AnalyzeParams,
  drive,
  execFileSyncWithImprovedExceptionMessage,
  getDriverCommandlineInputs,
  simpleSpawn
} from "../../../../src/driver";
import {
  BCVEAlert,
  BCVEResultStatus,
  CVEString,
  Dir,
  DriverConfig,
  File,
  RuleID
} from "../../../../src/persistent-types";
import { readJSONFile, writeJSONFile } from "../../../../src/util";

function main() {
  let { toolID, config } = getDriverCommandlineInputs();
  let driverConfig: DriverConfig<{ eslintDir: string }> = config.tools[toolID];
  let analyzer = makeAnalyzeFunction(
    driverConfig.options.eslintDir,
    driverConfig.timeout
  );

  drive(analyzer)
    .then(() => process.exit(0))
    .catch(e => {
      console.error(e);
      process.exit(1);
    });
}
main();

/**
 * @param eslintDir The directory where `npm i eslint ...` has been run.
 * @param timeout The number of milliseconds the analysis can run before it's forced to stop.
 * @return The analyze function that the driver invokes for each CVE
 */
function makeAnalyzeFunction(eslintDir: Dir, timeout: number): Analyze {
  return async function ({
    bcve,
    commitDescription,
    commitKind,
    tmp,
    setReproduction,
    setAlerts,
    setStatus
  }: AnalyzeParams) {
    // STEP 1: preparations for the run
    let eslintConfig = getESLintConfig(eslintDir, bcve.CVE);
    let eslint = path.join(
        eslintDir,
        "node_modules",
        "eslint",
        "bin",
        "eslint.js"
      ),
      // avoid relying on the `#!/usr/bin/env node` of eslint.js: explicitly reuse the parent `node` executable
      node = process.argv[0];

    // check if `eslint` works as expected
    execFileSyncWithImprovedExceptionMessage(node, [eslint, "--help"]);

    let tmpEslintDir = path.join(tmp, "eslint");
    // XXX this is a terrible hack to make the plugins be resolved appropriately wrt. the provided config file!
    console.log("Starting dependencies copy...");
    fs.copySync(eslintDir, tmpEslintDir);
    console.log("Finsihed copying dependencies!");
    let configFile = path.join(tmpEslintDir, "config.json");
    writeJSONFile(configFile, eslintConfig);

    let outputFile: File = path.join(tmp, "output.json"),
      args: string[] = [
        eslint,
        "--no-inline-config",
        "--no-eslintrc",
        "--config",
        configFile,
        "--output-file",
        outputFile,
        "--format",
        "json",
        "--no-error-on-unmatched-pattern",
        commitDescription.localSourceDirectory
      ];

    setReproduction(`# navigate to project
cd ${tmp}
# run eslint
${node} ${args.join(" ")}`);

    // STEP 2: run eslint
    try {
      const start = performance.now();
      await simpleSpawn(node, args, tmp, timeout, setStatus);
      const end = performance.now();

      try {
        const rawLoC = execSync(`cloc $(find ${commitDescription.localSourceDirectory})`, { encoding: "utf-8" });
        const jsLoC = rawLoC
          .split("\n")
          ?.filter((it) => it.includes("JavaScript") || it.includes("TypeScript") || it.includes("JSON"))
          ?.map((it) => it.split(" ")?.filter((it) => !!it))
          ?.reduce<[string, number, number, number, number]>(
            (acc, curr) => [
              acc[0] + curr[0],
              (acc[1] ?? 0) + Number(curr[1]),
              (acc[2] ?? 0) + Number(curr[2]),
              (acc[3] ?? 0) + Number(curr[3]),
              (acc[4] ?? 0) + Number(curr[4]),
            ],
            ["", 0, 0, 0, 0]
          );

        const stats = {
          analysisMs: end - start,
          meta: {
            CVE: bcve.CVE,
            ruleCount: eslintDir.includes("eslint-ours") ? 10 : 35,
            linesOfCode: {
              files: Number(jsLoC[1]),
              blank: Number(jsLoC[2]),
              comment: Number(jsLoC[3]),
              code: Number(jsLoC[4])
            }
          }
        };

        const eslintName = eslintDir.includes("eslint-ours") ? "eslint-ours" : "eslint-default";
        const statsName = `${eslintName}-${new Date().toISOString().replace(/[\:\.]/g, "-")}.json`;
        const folderName = path.join(process.cwd(), "work", "performance", bcve.CVE, commitKind);
        fs.mkdirpSync(folderName);
        fs.writeFileSync(path.join(folderName, statsName), JSON.stringify(stats, undefined, 2), { encoding: "utf-8" });
      } catch (err) {
        console.warn("Failed to write stats", err);
      }
    } catch (e) {
      if (e.code !== 1) {
        throw e;
      }
      // ignore exit code -1: it simply means that some rules matched
    }

    // STEP 3: process the eslint outputs
    setAlerts(
      convertEslintOutputToAlerts(
        outputFile,
        commitDescription.localSourceDirectory
      )
    );
    setStatus(BCVEResultStatus.SUCCESS);
  };
}

/**
 * Gets an ESLint configuration object for the provided CVE.
 */
function getESLintConfig(eslintDir: string, _cve: CVEString) {
  if (eslintDir.includes("eslint-ours")) {
    const config = {
      parserOptions: {
        ecmaVersion: 12,
        sourceType: "module",
        ecmaFeatures: {
          globalReturn: true,
          jsx: true
        }
      },
      env: {
        node: true,
        browser: true,
        es6: true
      },
      extends: ["plugin:security-rules/recommended"],
      overrides: [
        {
          files: ["*.ts", "*.tsx"],
          parser: "@typescript-eslint/parser",
        },
        {
          files: ["*.json"],
          parser: "jsonc-eslint-parser",
        },
      ],
    } as Record<string, unknown>;

    if (_cve === "CVE-2019-14772") {
      config.rules = {
        "security-rules/react/no-xss": ["error", {
          "sanitation": {
            "package": "xss",
            "method": "parseXSS",
            "usage": "parseXSS(<% html %>)"
          }
        }]
      }
    }

    return config;
  }

  // TODO make this use external data for the CVEs where this default config wrongly leads to parse errors
  return {
    parserOptions: {
      ecmaVersion: 12,
      sourceType: "module",
      ecmaFeatures: {
        globalReturn: true,
        jsx: true
      }
    },
    env: {
      node: true,
      browser: true,
      es6: true
    },
    plugins: ["security", "security-node"],
    extends: ["plugin:security/recommended", "plugin:security-node/recommended"],
    overrides: [
      {
        files: ["*.ts", "*.tsx"],
        parser: "@typescript-eslint/parser",
      },
      {
        files: ["*.json"],
        parser: "jsonc-eslint-parser",
      },
    ],
  };
}

/**
 * Converts the eslint rule violations in an output file to an array of alerts.
 *
 * @param eslintOutputFile the output from an eslint run (`--format json`)
 * @param localSourceDirectory the directory to make absolute violation locations relative to
 */
function convertEslintOutputToAlerts(
  eslintOutputFile: File,
  localSourceDirectory: Dir
): BCVEAlert[] {
  /*
    eslint outputs a json array with an array of rule violations per file:

    ```
    [ ...
      { "filePath": "/tmp/foo.js",
        "messages": [ ... { "ruleId": "xss", "line": 42 } ... ]
      }
      ... ]
  */
  type ESLintMessage = { ruleId: RuleID; line: number };
  type ESLintFileOutput = { filePath: File; messages: ESLintMessage[] };
  let eslintOutput: ESLintFileOutput[] = readJSONFile(eslintOutputFile);
  return eslintOutput.flatMap((f: ESLintFileOutput): BCVEAlert[] =>
    f.messages
      .filter(m => !!m.ruleId /* parsing error */)
      .map(m => ({
        ruleID: m.ruleId,
        location: {
          file: path.relative(localSourceDirectory, f.filePath),
          line: m.line
        }
      }))
  );
}
