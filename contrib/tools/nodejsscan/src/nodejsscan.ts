import * as path from "path";
import * as fs from "fs-extra";
import { performance } from "perf_hooks";
import {
  AnalyzeParams,
  drive,
  execFileSyncWithImprovedExceptionMessage,
  getDriverCommandlineInputs,
  simpleSpawn
} from "../../../../src/driver";
import { BCVEResultStatus, Dir, File } from "../../../../src/persistent-types";
import { convertSarifLogToAlerts, readJSONFile } from "../../../../src/util";
import { execSync } from "child_process";

/**
 * @param eslintDir The directory `<dir>` of `pip3 install -t <dir> njsscan ...`.
 * @param timeout The number of milliseconds the analysis can run before it's forced to stop.
 */
function analyzeWithDriver(njsscanDir: Dir, timeout: number): Promise<void> {
  async function analyze({
    bcve,
    commitDescription,
    commitKind,
    tmp,
    setReproduction,
    setAlerts,
    setStatus
  }: AnalyzeParams) {
    // STEP 1: preparations for the run
    let njsscanBinDir = path.join(njsscanDir, "bin"),
      njsscan = path.join(njsscanBinDir, "njsscan"),
      env = {
        ...process.env,
        PYTHONPATH: [njsscanDir, process.env.PYTHONPATH].join(path.delimiter),
        PATH: [njsscanBinDir, process.env.PATH].join(path.delimiter)
      };

    // check if `njsscan` works as expected
    execFileSyncWithImprovedExceptionMessage(njsscan, ["--help"], { env });

    let sarifFile: File = path.join(tmp, "results.sarif"),
      args: string[] = [
        "--sarif",
        "--output",
        sarifFile,
        "--missing-control",
        commitDescription.localSourceDirectory
      ];

    let reproduction = [
      `echo "Please set $PYTHONPATH and $PATH appropriately first"`,
      `cd ${tmp}`,
      `${njsscan} ${args.join(" ")}`
    ].join(" &&\n ");
    setReproduction(reproduction);

    // STEP 2: run njsscan
    const start = performance.now();
    await simpleSpawn(njsscan, args, tmp, timeout, setStatus, env);
    const end = performance.now();

    try {
      const rawLoC = execSync(`cloc $(find ${commitDescription.localSourceDirectory})`, { encoding: "utf-8" });
      const jsLoC = rawLoC
        .split("\n")
        ?.filter((it) => it.includes("JavaScript") || it.includes("TypeScript") || it.includes("JSON"))
        ?.map((it) => it.split(" ")?.filter((it) => !!it))
        ?.reduce<[string, number, number, number, number]>(
          (acc, curr) => [
            acc[0] + curr[0],
            (acc[1] ?? 0) + Number(curr[1]),
            (acc[2] ?? 0) + Number(curr[2]),
            (acc[3] ?? 0) + Number(curr[3]),
            (acc[4] ?? 0) + Number(curr[4]),
          ],
          ["", 0, 0, 0, 0]
        );

      const stats = {
        analysisMs: end - start,
        meta: {
          CVE: bcve.CVE,
          linesOfCode: {
            files: Number(jsLoC[1]),
            blank: Number(jsLoC[2]),
            comment: Number(jsLoC[3]),
            code: Number(jsLoC[4])
          }
        }
      };

      const statsName = `nodejsscan-${new Date().toISOString().replace(/[\:\.]/g, "-")}.json`;
      const folderName = path.join(process.cwd(), "work", "performance", bcve.CVE, commitKind);
      fs.mkdirpSync(folderName);
      fs.writeFileSync(path.join(folderName, statsName), JSON.stringify(stats, undefined, 2), { encoding: "utf-8" });
    } catch (err) {
      console.warn("Failed to write stats", err);
    }


    // STEP 3: process the njsscan outputs
    let alerts = convertSarifLogToAlerts(readJSONFile(sarifFile));
    // change the absolute URL paths in the sarif output to relative
    alerts.forEach(
      a =>
        (a.location.file = path.relative(
          commitDescription.localSourceDirectory,
          new URL(a.location.file).pathname
        ))
    );
    setAlerts(alerts);
    setStatus(BCVEResultStatus.SUCCESS);
  }
  return drive(analyze);
}

let { toolID, config } = getDriverCommandlineInputs();
analyzeWithDriver(
  config.tools[toolID].options.njsscanDir,
  config.tools[toolID].timeout
)
  .then(() => process.exit(0))
  .catch(e => {
    console.error(e);
    process.exit(1);
  });
